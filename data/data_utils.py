import numpy as np

import gzip
from data.util import load_dict

# Extra vocabulary symbols
PAD = '_PAD'
_GO = '_GO'
EOS = '_EOS' # also function as PAD
UNK = '_UNK'


extra_tokens = [PAD, _GO, EOS, UNK]

pad_token = extra_tokens.index(PAD)
start_token = extra_tokens.index(_GO)	# start_token = 0
end_token = extra_tokens.index(EOS)	# end_token = 1
unk_token = extra_tokens.index(UNK)


def define():
    config = {}
    config['malware'] = 0
    config['benign'] = 1
    config['trojan'] = 2
    config['backdoor'] = 3
    #TODO
    return config


def fopen(filename, mode='r'):
    if filename.endswith('.gz'):
        return gzip.open(filename, mode)
    return open(filename, mode)


def load_inverse_dict(dict_path):
    orig_dict = load_dict(dict_path)
    idict = {}
    for words, idx in orig_dict.iteritems():
        idict[idx] = words
    return idict

def seq2words(seq, inverse_target_dictionary):
    words = []
    for w in seq:
        if w == end_token:
            break
        if w in inverse_target_dictionary:
            words.append(inverse_target_dictionary[w])
        else:
            words.append(UNK)
    return ' '.join(words)

import random
# batch preparation of a given sequence
def prepare_batch(seqs_x, stride=None, maxlen=None, batch_size=None):
    maxlen = int(maxlen)
    stride = int(stride)
    while len(seqs_x) < batch_size:
        _add = (batch_size-len(seqs_x))%len(seqs_x)
        if _add == 0:
           _t = list(range(0, len(seqs_x))) * int((batch_size-len(seqs_x))/len(seqs_x))
        else:
           _t = random.sample(range(0, len(seqs_x)), _add)
        seqs_x.extend(seqs_x[i] for i in _t)
    res = []
    lengths_x = []
    for ss in seqs_x:
        _ss = []
        diff = maxlen - len(ss) % stride
        if maxlen and len(ss) % stride != 0:
            ss.extend([end_token])
            if diff > 1:
               ss.extend([pad_token]*(diff-1))
        for i in range(0, len(ss)-maxlen+1, stride):
            _ss.append(ss[i: i+maxlen])
            if (ss[i+maxlen-1] != pad_token and ss[i+maxlen-1] != end_token):
               lengths_x.append(maxlen)
            else:
               lengths_x.append(maxlen-diff)
        res.append(_ss)
    return np.array(res), np.array(lengths_x)

def prepare_batch_without_window(seqs_x, batch_size=None):
    while len(seqs_x) < batch_size:
        _add = (batch_size-len(seqs_x))%len(seqs_x)
        if _add == 0:
            _t = list(range(0, len(seqs_x))) * int((batch_size-len(seqs_x))/len(seqs_x))
        else:
            _t = random.sample(range(0, len(seqs_x)), _add)
        seqs_x.extend(seqs_x[i] for i in _t)
    res = []
    lengths_x = [len(s) for s in seqs_x]
    maxlen = np.max(lengths_x)
    for ss in seqs_x:
        diff = maxlen - len(ss)
        if diff > 0:
            ss.extend([end_token])
            if diff > 1:
               ss.extend([pad_token]*(diff-1))
        res.append([ss])
    return np.array(res), np.array(lengths_x)

def readMalware(source, key):
    source = fopen(source, 'r')
    mws = []
    for line in source:
        if int(line.strip().split()[-1]) == key:
            mws.append(line.strip().split()[:-1])
    return mws

import tensorflow as tf
#insert seq1 into seq2(list)
def insertSequence(seq1, seq2, N, batch_size):
    batchs = []
    for index in range(1, N+1):
        res = []
        for i in range(batch_size):
           _i = random.sample(range(len(seq2[i])))
           _tmp = seq2[i]
           _tmp[_i:_i] = seq1[i]
           res.append(_tmp)
        batchs.append(res)
    return batchs

