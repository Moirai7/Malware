import numpy as np

import gzip

# Extra vocabulary symbols
PAD = '_PAD'
_GO = '_GO'
EOS = '_EOS' # also function as PAD
UNK = '_UNK'


extra_tokens = [PAD, _GO, EOS, UNK]

pad_token = extra_tokens.index(PAD)
start_token = extra_tokens.index(_GO)	# start_token = 0
end_token = extra_tokens.index(EOS)	# end_token = 1
unk_token = extra_tokens.index(UNK)

malware_label = 0
benign_label = 1


def fopen(filename, mode='r'):
    if filename.endswith('.gz'):
        return gzip.open(filename, mode)
    return open(filename, mode)


def load_inverse_dict(dict_path):
    from data.util import load_dict
    orig_dict = load_dict(dict_path)
    idict = {}
    for words, idx in orig_dict.iteritems():
        idict[idx] = words
    return idict

def seq2words(seq, inverse_target_dictionary):
    words = []
    for w in seq:
        if w == end_token:
            break
        if w in inverse_target_dictionary:
            words.append(inverse_target_dictionary[w])
        else:
            words.append(UNK)
    return ' '.join(words)

import random
# batch preparation of a given sequence
def prepare_batch(seqs_x, label, stride=None, maxlen=None, batch_size=None, max_batch=1000000):
    maxlen = int(maxlen)#window size
    stride = int(stride)#stride
    '''
    while len(seqs_x) < batch_size:
        _add = (batch_size-len(seqs_x))%len(seqs_x)
        if _add == 0:
           _t = list(range(0, len(seqs_x))) * int((batch_size-len(seqs_x))/len(seqs_x))
        else:
           _t = random.sample(range(0, len(seqs_x)), _add)
        seqs_x.extend(seqs_x[i].copy() for i in _t)
        label.extend(label[i] for i in _t)
    '''
    res_seq = []
    res_label = []
    _seq = []
    _label = []
    lengths_x = []
    total_num = 0
    for ss, _ll in zip(seqs_x, label):
        _ss = []
        ss.insert(0, start_token)
        ss.extend([end_token])
        if len(ss) <= maxlen:
            ss.extend([pad_token]*(maxlen - len(ss)))
            _ss.append(ss)
        else :
          for i in range(0, len(ss)):
            end = i*stride+maxlen
            start = i*stride
            if end >= len(ss):
                ss.extend([pad_token]*(end - len(ss)))
                _ss.append(ss[start: end])
                break
            _ss.append(ss[start: end])
        if total_num + len(_ss) > max_batch:
            res_seq.append(np.array(_seq))
            res_label.append(np.array(_label))
            total_num = 0
            _seq = []
            _label = []
        total_num += len(_ss)
        _seq.append(_ss)
        _label.append(_ll)
    res_seq.append(np.array(_seq))
    res_label.append(np.array(_label))
    return np.array(res_seq), np.array(res_label)

def prepare_batch_without_window(seqs_x, batch_size=None):
    while len(seqs_x) < batch_size:
        _add = (batch_size-len(seqs_x))%len(seqs_x)
        if _add == 0:
            _t = list(range(0, len(seqs_x))) * int((batch_size-len(seqs_x))/len(seqs_x))
        else:
            _t = random.sample(range(0, len(seqs_x)), _add)
        seqs_x.extend(seqs_x[i] for i in _t)
    res = []
    lengths_x = [len(s) for s in seqs_x]
    maxlen = np.max(lengths_x)
    for ss in seqs_x:
        diff = maxlen - len(ss)
        if diff > 0:
            ss.extend([end_token])
            if diff > 1:
               ss.extend([pad_token]*(diff-1))
        res.append([ss])
    return np.array(res), np.array(lengths_x)

def readMalware(source, key):
    source = fopen(source, 'r')
    mws = []
    for line in source:
        if int(line.strip().split()[-1]) == key:
            mws.append(line.strip().split()[:-1])
    return mws

import tensorflow as tf
#insert seq1 into seq2(list)
def insertSequence(seq1, seq2, N, batch_size):
    batchs = []
    for index in range(1, N+1):
        res = []
        for i in range(batch_size):
           _i = random.sample(range(len(seq2[i])))
           _tmp = seq2[i]
           _tmp[_i:_i] = seq1[i]
           res.append(_tmp)
        batchs.append(res)
    return batchs

