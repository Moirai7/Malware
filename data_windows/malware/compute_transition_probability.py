import json
#import cPickle as pkl
import pickle as pkl
import numpy as np
# Extra vocabulary symbols
PAD = 'PAD'
_GO = '_GO'
EOS = '_EOS' # also function as PAD
UNK = '_UNK'


extra_tokens = [PAD, _GO, EOS, UNK]

pad_token = extra_tokens.index(PAD)
start_token = extra_tokens.index(_GO)   # start_token = 0
end_token = extra_tokens.index(EOS)     # end_token = 1
unk_token = extra_tokens.index(UNK)

malware_label = 0
benign_label = 1


#json loads strings as unicode; we currently still work with Python 2 strings, and need conversion
def unicode_to_utf8(d):
    #return dict((key.encode("UTF-8"), value) for (key,value) in d.items())
    return dict((key, value) for (key,value) in d.items())

def load_dict(filename):
    try:
        with open(filename, 'rb') as f:
            data = f.read()
            return unicode_to_utf8(json.loads(data.decode()))
    except:
        with open(filename, 'rb') as f:
            return pkl.load(f)

def load_voc(filename):
    try:
        with open(filename, 'rb') as f:
            data = f.read()
            data = json.loads(data.decode())
            return [value for key, value in data.items()]
    except:
        with open(filename, 'rb') as f:
            return pkl.load(f)


def rewritevoc():
    with open('voc.json', 'rb') as f:
        data = f.read()
        data = json.loads(data.decode())
        for key, value in data.items():
            value = value - 4
            data[key] = value
        for key in extra_tokens:
            data.pop(key, None)
        json.dump(data,open('voc.json','w'))

#rewritevoc()
fn = 'voc.json'
voc = load_dict(fn)

def transition_matrix(seq, num):
   M = [[0]*num for _ in range(num)]
   for (i, j) in zip(seq, seq[1:]):
        M[i][j] += 1
   for row in M:
        s = sum(row)
        if s>0:
           row[:] = [f/s for f in row]
   return M

def transform(seqs, name):
   num = len(load_voc(fn))
   with open(seqs, 'r') as f:
      res = []
      y = []
      i = 0
      for line in f:
        line = line.strip('\n')
        if (len(line.split(' '))==1):
           continue
        ss = line.split(' ')[:-1]
        y.append(line.split(' ')[-1])
        data = transition_matrix([voc[w] if w in voc else unk_token for w in ss],num)
        #savetojson(data, y[-1], num, name + '/' + str(i))
        i = i + 1
        res.append(data)
        #res.append([k for row in data for k in row])
   return res,y

#m, y = transform('train.seq', 'train')
#np.save('malware.train.graphs.sample.npy', np.asarray(m))
#np.save('malware.train.labels.sample.npy', np.asarray(y))
#m, y = transform('valid.seq', 'valid')
#np.save('malware.valid.graphs.sample.npy', np.asarray(m))
#np.save('malware.valid.labels.sample.npy', np.asarray(y))
'''
k =['100','300','400','1000','2000','3000']
for i in k:
  m, y = transform('../valid_'+i+'.seq', 'valid')
  np.save('malware.valid.graphs.'+i+'.npy', np.asarray(m))
  np.save('malware.train.graphs.'+i+'.npy', np.asarray(m))
  np.save('malware.valid.labels.'+i+'.npy', np.asarray(y))
  np.save('malware.train.labels.'+i+'.npy', np.asarray(y))
'''
mwlist = ['apiseq_all_Backdoor.csv','apiseq_all_Trojan-Downloader.csv','apiseq_all_Trojan-Ransom.csv','apiseq_all_AdWare.csv','apiseq_all_Worm.csv']
for i in mwlist:
   valid = '../'+i+'_valid.seq'
   m,y = transform(valid, 'valid')
   np.save('malware.valid.graphs.'+i+'.npy', np.asarray(m))
   np.save('malware.train.graphs.'+i+'.npy', np.asarray(m))
   np.save('malware.valid.labels.'+i+'.npy', np.asarray(y))
   np.save('malware.train.labels.'+i+'.npy', np.asarray(y))


import json
def savetojson(data, target, num, fn):
   res = {}
   res['target'] = int(target)
   labels = {}
   edges = []
   index = 0
   for i in range(num):
     for j in range(num):
        if(data[i][j] > 0):
           if i in labels.keys():
               start = labels[i]
           else:
               start = index
               labels[i] = index
               index = index + 1
           if j in labels.keys():
               end = labels[j]
           else:
               end = index
               labels[j] = index
               index = index + 1
           edges.append([start, end])
   res['edges'] = edges
   res['labels'] = {v:k for k,v in labels.items()}
   res['inverse_labels'] = {k:[v] for k,v in labels.items()}
   json.dump(res,open(fn + '.json', 'w'))



import gensim
def word2vec(seq1, seq2):
   with open(seq1,'r') as f1:
     with open(seq2,'r') as f2:
       data = []
       for ss in f1:
          data.append(ss.split(' ')[:-1])
       for ss in f2:
          data.append(ss.split(' ')[:-1])
       model = gensim.models.Word2Vec(data, min_count = 1, size = 100, window = 5) 
       #model = gensim.models.Word2Vec(data, min_count = 1, size = 100, window = 5, sg = 1) 
       model.wv.save_word2vec_format('malware.content',binary=False)
       return model

#print(word2vec('valid.seq', 'train.seq'))
